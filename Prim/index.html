<!DOCTYPE html>
<html lang="en-us">
  <head>
    <meta charset="UTF-8">
    <meta name="author" content="ihaiu" />
    <title>最小生成树之Prim普里姆算法</title>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel="stylesheet" type="text/css" href="/stylesheets/normalize.css" media="screen">
    <link href='https://fonts.googleapis.com/css?family=Open+Sans:400,700' rel='stylesheet' type='text/css'>
    <link rel="stylesheet" type="text/css" href="/stylesheets/stylesheet.css" media="screen">
    <link rel="stylesheet" type="text/css" href="/stylesheets/github-light.css" media="screen">
    <link type="text/css" rel="stylesheet" href="/stylesheets/offlintab-439.css">
    <link type="stylesheet" rel="stylesheet" href="/stylesheets/font-awesome.min.css">
    <!-- <link type="stylesheet" rel="stylesheet" href="/stylesheets/about-grid.css"> -->


    <!-- <link href="/feed/" rel="alternate" title="ihaiu" type="application/atom+xml" /> -->

    <link rel="shortcut icon" href="/assets/icon/favicon.ico" />

    <link href="/assets/icon/favicon.ico" type="image/x-icon" rel="shortcut icon bookmark" />
    <link rel="apple-touch-icon-precomposed" href="assets/icon/icon32.png">
    <link rel="apple-touch-icon-precomposed" sizes="76x76" href="/assets/icon/icon76.png">
    <link rel="apple-touch-icon-precomposed" sizes="120x120" href="/assets/icon/icon120.png">
    <link rel="apple-touch-icon-precomposed" sizes="152x152" href="/assets/icon/icon152.png">

  <!-- 
  <script src="http://www.it165.net/statics/js//it165_pro.js" type="text/javascript"></script>
  <script type="text/javascript">SyntaxHighlighter.all();</script>
  -->


           
    <script type="text/javascript" src="/media/syntaxhighlighter_2.0.278/scripts/shCore.js"></script>
    <link type="text/css" rel="stylesheet" href="/media/syntaxhighlighter_2.0.278/styles/shCore.css"/>
    <link type="text/css" rel="stylesheet" href="/media/syntaxhighlighter_2.0.278/styles/shThemeDefault.css"/>


      

      

      

      

      

      

      

      

      

      

      

      


      

      
      <script type="text/javascript" src="/media/syntaxhighlighter_2.0.278/scripts/shBrushJScript.js"></script>
      
      

      

      

      

      

      

      

      

      

      

      

      



    <script type="text/javascript">SyntaxHighlighter.all();</script>


   

  </head>

  <body>
    <section class="page-header">
      <a href="http://www.ihaiu.com" class="iconbtn"><h1 style="background-image: url('/assets/icon/icon76_white.png'); background-position: center center; background-repeat:no-repeat; height:76px; margin:0px;"></h1></a>
      <a href="http://www.ihaiu.com" class="iconbtn"><h1 class="project-name" >爱海游</h1></a>
      <h2 class="project-tagline">ihaiu.com</h2>
      <a href="/#content" class="btn">目录</a>
      <a href="/categories/#content" class="btn">分类</a>
     <!--  <a href="/guestbook/#content" class="btn">留言</a> -->
     <!--  <a href="/about/#content" class="btn">关于</a> -->
      <a href="/opensource/#content" class="btn">开源分享</a>
      <a href="/share/#content" class="btn">分享</a>
     <!--  <a href="/share/gameart#content" class="btn">游戏美术</a> -->
      <a href="/friendlylink/#content" class="btn">友情链接</a>
    </section>





    <section class="main-content" id="content">

      <h1>最小生成树之Prim普里姆算法</h1>
      <article class="content">
        <section class="meta">
<span class="time">
  <time datetime="2018-12-29">2018-12-29</time>
</span>

 | 
<span class="categories">
  发布
  <a href="tencent://message/?uin=593705098" title="发布:大海明月 QQ:593705098" rel="author">大海明月</a>&nbsp;
  
  <a href="mailto:zengfeng75@qq.com" title="发布:大海明月 Email:zengfeng75@qq.com" rel="author">zengfeng75@qq.com</a>&nbsp;
  
</span>



 | 
<span class="categories">
  分类
  
  <a href="/categories/#算法" title="算法">算法</a>&nbsp;
  
</span>


 | 
<span class="tags">
  标签
  
  <a href="/tags/#算法" title="算法">算法</a>&nbsp;
  
</span>

</section>
<section class="post">
<p><br />
<br /></p>

<h3 id="相关链接">相关链接</h3>

<p><a href="https://www.lintcode.com/problem/minimum-risk-path/description" target="_blank">783. 最小危险值路径</a><br />
<a href="https://blog.csdn.net/qq_35644234/article/details/59106779" target="_blank">数据结构–最小生成树详解</a><br />
<a href="https://blog.ihaiu.com/Floyd/#content" target="_blank">最短路径算法之 Floyd</a><br /></p>

<h3 id="在线测试">在线测试</h3>

<p><a href="https://blog.ihaiu.com/web/path_algorithm/index.html" target="_blank">寻路算法 在线测试</a><br /><br /></p>

<p>1. 点击右边的测试数据按钮，可以切换数据</p>
<p><img src="https://blog.ihaiu.com/web/path_algorithm/doc/images/01.gif" style="border: solid 1px #666;" /></p>
<p><br /></p>

<p>2. 点击右边的最小生成树，可以切换是否开启这功能</p>
<p><img src="https://blog.ihaiu.com/web/path_algorithm/doc/images/02.gif" style="border: solid 1px #666;" /></p>
<p><br /></p>

<p>3. 点击右边的操作模式<br />
* 拖动节点： 可以拖动节点，默认都可以
* 设置起始点： 选中该模式，再点击节点，可以将该节点设置为最短寻路起始点。节点下标Start<br />
* 设置结束点： 选中该模式，再点击节点，可以将该节点设置为最短寻结束点。节点下标End<br />
寻得的路线为绿色连线，红色表示该路线中成本最大的值

</p>
<p><img src="https://blog.ihaiu.com/web/path_algorithm/doc/images/03.gif" style="border: solid 1px #666;" /></p>
<p><br /></p>

<p>4. 修改数据 <br />
(1) 先点击“导出数据按钮”，会在页面下方输出图形json数据 <br />
(2) 编辑数据，点提交就可以修改了。只需要修改属性 x(起点), y(目标点), w(成本)
</p>

<p><img src="https://blog.ihaiu.com/web/path_algorithm/doc/images/04.gif" style="border: solid 1px #666;" /></p>
<p><br /></p>

<h3 id="primts">Prim.ts</h3>

<pre class="brush: js; ">
namespace ihaiu
{
    /** 作为记录边的信息，这些边都是达到end的所有边中，权重最小的那个 */
    export class PrimAssis
    {
        // 边的终点
        start: number = 0;
        // 边的起点
        end: number = 0;
        // 边的权重
        weight: number = 0;
    }

    /** 最小生成树之Prim普里姆算法 */
    export class Prim
    {

        // 成本矩阵
        arcs: number[][];

        // 计算结果
        result: GraphData;

        constructor()
        {

        }


        /** 获取路径成本 */
        public getArcs(from: number, to: number): number
        {
            return this.arcs[from][to];
        }


        /** 是否有连接线 */
        public hasEdge(from: number, to: number): boolean
        {
            let arc = this.getArcs(from, to);
            return arc != Number.MAX_VALUE &amp;&amp; arc != 0;
        }

        public calculationByGraphData(g: GraphData, beginIndex: number = 0):GraphData
        {
            g.check();
            let g2 = this.calculation(
                            g.nodeNum, 
                            g.edegeNum,
                            g.x,
                            g.y,
                            g.w,
                            beginIndex
                            );

            g2.nodeNum = g.nodeNum;             
            g2.nodes = g.nodes;
            return g2;
        }


        /** 计算寻路 */
        public calculation(nodeNum: number, edegeNum: number, x: number[], y: number[], w: number[], beginIndex: number = 0):GraphData
        {
            // 结果图
            let result: GraphData = new GraphData().init();

            // 成本矩阵
            let arcs: number[][] = [];


            // 初始化矩阵值
            for(let u = 0; u &lt; nodeNum; u ++)
            {
                arcs[u] = [];

                for(let v = 0; v &lt; nodeNum; v ++)
                {
                    arcs[u][v] = Number.MAX_VALUE;
                }
            }


            // 输入边
            for(let i = 0; i &lt; x.length; i ++)
            {
                let u = x[i];
                let v = y[i];
                arcs[u][v] = w[i];
                arcs[v][u] = w[i];
            }

            //closeEdge这个数组记录到达某个顶点的各个边中的权重最大的那个边
            let closeEdges: PrimAssis[] = [];
            for(let i = 0; i &lt; nodeNum; i ++)
            {
                closeEdges.push(new PrimAssis());
            }

            //进行closeEdge的初始化，更加开始起点进行初始化
            for(let i = 0; i &lt; nodeNum; i ++)
            {
                if(i != beginIndex)
                {
                    let edge = closeEdges[i];
                    edge.start = beginIndex;
                    edge.end = i;
                    edge.weight = arcs[beginIndex][i];
                }
            }

            //把起点的closeEdge中的值设置为-1，代表已经加入到集合U了
            closeEdges[beginIndex].weight = -1;

             //访问剩下的顶点，并加入依次加入到集合U
             for(let i = 1; i&lt; nodeNum; i ++)
             {
                let minWeight = Number.MAX_VALUE;
                let minIndex = 0;
                //寻找数组close_edge中权重最小的那个边
                for(let k = 0; k &lt; nodeNum; k ++)
                {
                    if(closeEdges[k].weight != -1)
                    {
                        if(closeEdges[k].weight &lt; minWeight)
                        {
                            minWeight = closeEdges[k].weight;
                            minIndex = k;
                        }
                    }
                }

                let minEdge = closeEdges[minIndex];

                //将权重最小的那条边的终点也加入到集合U
                minEdge.weight = -1;


                //输出对应的边的信息
                result.addEdge(
                    minEdge.start, 
                    minEdge.end, 
                    arcs[minEdge.start][minEdge.end]
                    );

                    //更新我们的close_edge数组。
                    for (let k = 0; k &lt; nodeNum; k++) {
                        let edge = closeEdges[k];
                        if (arcs[minEdge.end][k] &lt; edge.weight) 
                        {
                            edge.weight = arcs[minEdge.end][k];
                            edge.start = minEdge.end;
                            edge.end = k;
                        }
                    }


             }

             this.arcs = arcs;
             this.result = result;
             return result;
        }







    }
}
</pre>

<h3 id="graphdatats">GraphData.ts</h3>

<pre class="brush: js; ">
namespace ihaiu
{
    /**
     * 图形数据
     */
    export class GraphData
    {
        // 边--from
        x: number[];
        // 边--to
        y: number[];
        // 边--危险值
        w: number[];

        // 节点数量
        nodeNum = 0;

        // 边数
        edegeNum = 0;

        // 节点
        nodes: Node[] = [];

        public init(): GraphData
        {
            this.x = [];
            this.y = [];
            this.w = [];
            return this;
        }

        // 添加边
        public addEdge(x: number, y:number, w: number): GraphData
        {
            this.x.push(x);
            this.y.push(y);
            this.w.push(w);
            return this;
        }

        public check()
        {
            this.checkNodeNum();
            this.edegeNum = this.x.length;
            if(this.nodes != null &amp;&amp; this.nodes.length &gt;= this.nodeNum)
            {
                return;
            }

            let list: Node[] = [];
            for(let i = 0; i &lt; this.nodeNum; i ++)
            {

                let node : Node;
                
                if(i &lt; this.nodes.length )
                {
                    node = this.nodes[i];
                } 
                else
                {
                    node = new Node();
                    node.pos.x = Math.floor( Math.random() * 200 + 50 ) ;
                    node.pos.y = Math.floor( Math.random() * 200 + 50 );

                }
                node.index = i;
                list.push(node);
            }
            this.nodes = list;
        }

        // 矫正顶点数量
        public checkNodeNum()
        {
            let x = this.x;
            let y = this.y;
            let num = 0;
            for(let i = 0; i &lt; x.length; i ++)
            {  
                num = Math.max(x[i], num);
                num = Math.max(y[i], num);
            }
            this.nodeNum = Math.max(num + 1, this.nodeNum);
        }

        static parse(json:string)
        {
            let g = new GraphData();
            try 
            {
                let o = JSON.parse(json);
                g.edegeNum = o.edegeNum;
                g.nodeNum = o.nodeNum;
                g.x = o.x;
                g.y = o.y;
                g.w = o.w;

                let list: Node[] = [];
                for(let i = 0; i &lt; o.nodes.length; i ++)
                {
                    let item = o.nodes[i];

                    let node : Node = new Node();
                    node.index = item.index;
                    node.pos.x = item.pos.x;
                    node.pos.y = item.pos.y;
                    list.push(node);
                }
                g.nodes = list;

            } 
            catch (error) 
            {
                alert(&quot;解析json数据错误：&quot; + error);
            }
            return g;
        }


    }
}
</pre>

<h3 id="nodets">Node.ts</h3>

<pre class="brush: js; ">
namespace ihaiu
{
    export class NodeState
    {
        static Normal = 0;
        static Disable = 1;
        static Start = 2;
        static End = 3;
        static Greend = 4;
    }

    export class LineState
    {
        static Normal = 0;
        static Disable = 1;
        static Green = 2;
        static GreenMax = 3;
    }

    /**
     * 节点
     */
    export class Node
    {
        // 节点索引
        index: number;
        // 坐标
        pos: Point = new Point();
        // 子节点
        // childes: Node[] = [];
    }
}
</pre>

<h3 id="pointts">Point.ts</h3>

<pre class="brush: js; ">
namespace ihaiu
{
    /**
     * 路径点
     */
    export class Point
    {
        x: number = 0;
        y: number = 0;

        /** 获取到目标点距离 */
        public getDistance(to: Point): number
        {
            let dx  = to.x - this.x;
            let dy  = to.y - this.y;
            return Math.sqrt(dx * dx + dy * dy);
        }

        /** 获取到目标点弧度 */
        public getRadian(to: Point) : number
        {
            let dx  = to.x - this.x;
            let dy  = to.y - this.y;
            return Math.atan2(dy, dx);
        }

        /** 获取到目标点角度 */
        public getAngle(to: Point) : number
        {
            return this.getRadian(to) * 180 / Math.PI ;
        }

        /** 获取中心点 */
        public static center(a: Point, b: Point): Point
        {
            let p = new Point();
            p.x = a.x + (b.x - a.x) * 0.5;
            p.y = a.y + (b.y - a.y) * 0.5;
            return p;
        }


        /** 获取相对A中心点 */
        public static centerRelative(a: Point, b: Point): Point
        {
            let p = new Point();
            p.x = (b.x - a.x) * 0.5;
            p.y = (b.y - a.y) * 0.5;
            return p;
        }

    }
}
</pre>

</section>
<section class="page">

	 
  <span><a href="/Floyd/#content" class="pageNav"  >上一篇: 最短路径算法之 Floyd</a></span>
  <br/>
  

  
	<span><a href="/tool-Unlock/#content" class="pageNav"  >下一篇: Unlock 解锁文件占用</a></span>
   

</section>


<div id="cloud-tie-wrapper" class="cloud-tie-wrapper"></div>
<script>
  var cloudTieConfig = {
    url: document.location.href, 
    sourceId: "20181018160000",
    productKey: "97dc4b8e4aeb41ca8606d2c6efa6eae3",
    target: "cloud-tie-wrapper"
  };
</script>
<script src="https://img1.cache.netease.com/f2e/tie/yun/sdk/loader.js"></script>


      </article>


      <footer class="site-footer">

          <script>
var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "//hm.baidu.com/hm.js?aa2fdee733dec8a2399b5bc0efbfd843";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script>

        <span class="site-footer-credits"><a href="http://www.ihaiu.com">爱海游</a></span> |
        <span class="site-footer-credits"><a href="http://blog.ihaiu.com">博客</a></span> |

        <script src="http://s4.cnzz.com/z_stat.php?id=1260003113&web_id=1260003113" language="JavaScript"></script>

        <p align="center">版权所有：©2021 ihaiu.com 版权所有ICP证： <a href="https://beian.miit.gov.cn/" target="_blank">沪ICP备2021002336号</a></p>
      </footer>

    </section>


  
  </body>
</html>


